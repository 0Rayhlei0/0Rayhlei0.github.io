<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>HideOnRubbish | RayHLei</title>
    <link>http://raylei.space/</link>
    
    <atom:link href="http://raylei.space/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>一个给保险公司做数据分析的人</description>
    <pubDate>Thu, 24 Feb 2022 15:05:26 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[编程算法] 到底什么是“面向对象编程(OOP)”</title>
      <link>http://raylei.space/2022/02/23/5-What_is_object_oriented_programming/</link>
      <guid>http://raylei.space/2022/02/23/5-What_is_object_oriented_programming/</guid>
      <pubDate>Wed, 23 Feb 2022 15:47:32 GMT</pubDate>
      
      <description>本篇介绍了对程序员来说一定要知道的最基础的知识，什么是“面向对象编程(OOP)&quot;什么是&quot;面向过程编程(POP)&quot;。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本篇介绍了对“程序员”来说很可能是第一个难点ever，但又绝不能不知道的<code>面向对象编程(Object Oriented Programming)</code>和<code>面向过程编程(Procedural Oriented Programming)</code>，由于我自己本科学的是金融数学，二硕学个计算机吧又是金融计算方向(选课偏向<code>数据分析</code>而非<code>软件开发</code>)，因此基本上在编程的时候使用的都只是简单易懂的<code>“面向过程编程”</code>的方法，因此本篇我就要好好研究一下到底什么叫<code>“面向对象编程”</code>。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在写上一篇博文的时候，我把<a href="https://selenium-python.readthedocs.io/index.html" title="SeleniumwithPython">Selenium with Python</a>的文档看了一遍，看着看着忽然觉得有些吃力，这才想起来我有一个东西一直都是半懂不懂，那就是传说中所谓的<code>面向对象编程(Object Oriented Programming)</code>和<code>面向过程编程(Procedural Oriented Programming)</code>。这导致我在看别人代码的时候总是没有那种融汇贯通心领神会的感觉，作为“<code>1/4”</code>个计算机<code>“科班出生”</code>的<code>“1/4程序员”</code>这怎么行？所以我今天就要把这个东西彻底啃透。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>根据这篇<a href="https://zhuanlan.zhihu.com/p/75265007" title="2分钟让你明白什么是面向对象编程">知乎文章</a>的解释，<code>面向过程</code>与<code>面向对象</code>这两种编程方式拥有各自的优缺点。通俗一点解释就是<strong>：</strong></p><ul><li><p><strong>面向过程：</strong> 顾名思义，编程方式注重过程。在解决一个问题的时候这种编程方式需要把解决方式拆分成一个个过程，按照一定的顺序执行完这些方法(methods)，方法执行完问题就解决了。</p></li><li><p><strong>面向对象：</strong>同样名字就已经非常清晰了，注重的是程序互动的对象。解决问题的时候面向对象编程是将事物抽象成对象，那问题里可能涉及的事物都定义成一个程序对象，然后给这个对象赋上一些<code>属性(Properties)</code>和<code>方法(methods)</code>。让各个对象去执行自己的方法以此来解决问题。</p></li></ul><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>我引用<a href="https://zhuanlan.zhihu.com/p/75265007" title="2分钟让你明白什么是面向对象编程">呜呜轩轩</a>提到的我觉得对于我的理解起到重要帮助的两个例子，分别是洗衣服和做饭。</p><h4 id="洗衣服"><a href="#洗衣服" class="headerlink" title="洗衣服"></a>洗衣服</h4><p>假设有一个问题：要用洗衣机洗干净脏衣服，如何执行？</p><p><strong><code>面向过程</code>的解决方法</strong>：</p><ol><li>执行加洗衣粉的方法；</li><li>执行加水的方法；</li><li>执行洗衣服的方法；</li><li>执行清洗的方法；</li><li>执行烘干的方法；</li></ol><p>将解决过程拆分成一个个方法，不用调用对象，通过执行一个个方法来解决问题。</p><p><strong><code>面向对象</code>的解决方法：</strong></p><ol><li>先抽象出两个对象，分别是<code>洗衣机</code>和<code>人</code></li><li>针对对象<code>洗衣机</code>加入一些属性和方法：“洗衣服方法”，”清洗方法“，”烘干方法“</li><li>针对对象<code>人</code>加入一些属性和方法：“加洗衣粉方法”，“加水方法”</li><li>然后执行：<code>人.加洗衣粉→人.加水→洗衣机.洗衣服→洗衣机.清洗→洗衣机.烘干</code></li></ol><p>同一个问题，面向对象编程需要先定义对象然后靠对象执行方法的方式解决问题。</p><h4 id="做饭"><a href="#做饭" class="headerlink" title="做饭"></a>做饭</h4><p>呜呜轩轩引用了@十四期_李光的说法，分别将<code>面向过程编程</code>和<code>面向对象编程</code>比喻成<code>蛋炒饭</code>和<code>盖浇饭</code>。以此来说明两种方法的优缺点：</p><ul><li><code>面向过程编程就像蛋炒饭</code>，食材和饭交融在一起，难以分开，其味道可能均匀易于入口，但一旦做好就很难再改变。</li><li><code>面向对象编程就像盖浇饭</code>，食材和饭是分开的，食客在同时能享受到食材和饭的同时，如果想要换一个口味也只需要将不同的菜与之前的饭放在一起就可以了。</li></ul><p>回到现实，这两种方法各自的优缺点就是：</p><ul><li>面向过程编程性能高于面向对象编程，缺点是不易维护，难以扩展，难以复用。适合需要性能优先的场景。</li><li>面向对象编程就是相反了，性能略低但易维护易扩展，结构更加灵活。适合大而复杂的软件开发。</li></ul><p>这两个例子一个让人了解这两种方法在表达形式上的区别，一个让人了解各自的优缺点，我觉得非常方便概念比较模糊的人理解。</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>我个人觉得<code>面向过程编程</code>是非常<code>straightforward</code>的，所以除了两者的对比以外，我不打算细说面向过程编程。那在这一节我就还是用我从网上学到的内容(主要还是<a href="https://zhuanlan.zhihu.com/p/75265007" title="2分钟让你明白什么是面向对象编程">呜呜轩轩</a>和<a href="https://www.udacity.com/blog/2021/11/__init__-in-python-an-overview.html" title="__init__ in Python: An Overview">Alexey</a>)现学现卖，详细讲讲面向对象编程的三大特征和五大原则，以及其实际的实现方法等。</p><h3 id="三大基本特征"><a href="#三大基本特征" class="headerlink" title="三大基本特征"></a>三大基本特征</h3><p><strong>封装(Encapsulation)：</strong>把客观事物封装成抽象的<code>类(Class)</code>，而类可以把自己的<code>属性(Property)</code>和<code>方法(methods)</code>只让可信的类或者对象操作，对不可信的进行信息隐藏(public和private)。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。</p><p><strong>继承(Inheritance)：</strong>让某个类型的对象获得另一个类型对象的属性的方法。继承使新类可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展，通过继承创建的新类称为<code>“子类(Subclass)”</code>或<code>“派生类(Derived class)”</code>，被继承的类称为<code>“基类(Base class)”</code>，<code>“父类(Parent class)”</code>或<code>“超类(Super class)”</code>。继承的过程就是从<code>一般(generalized)</code>到<code>特殊(specialized)</code>的过程。要实现继承，可以通过<code>“继承(Inheritance)”</code>和<code>“组合(Composition)”</code>来实现。继承概念的实现方式有两类：<code>实现继承(Implementation inheritance)</code>与<code>接口继承(Interface inheritance)</code>。前者指直接使用父类的属性和方法而无需额外编码的能力；后者则是指仅使用属性和方法的名称，但子类必须提供实现的能力。</p><p><strong>多态(Polymorphism)：</strong>指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着虽然针对不同对象的具体操作不同，但通过一个公共的类，它们可以通过相同的方式予以调用。</p><h3 id="五大基本原则"><a href="#五大基本原则" class="headerlink" title="五大基本原则"></a>五大基本原则</h3><p><strong>单一职责原则SRP(Single Responsibility Principle)：</strong>指一个类的功能要单一，不能混杂什么都有。</p><p><strong>开放封闭原则OCP(Open－Close Principle)：</strong>一个模块在扩展性方面应该是开放的，而在更改性方面应该是封闭的。比如：一个网络模块，原来只有服务端功能，在现在要加入客户端功能，那么就应该在不用修改已有功能代码的前提下就能增加客户端的实现代码，这要求在设计之初就将两个部分分开，将公共部分抽象出来。</p><p><strong>里式替换原则LSP(the Liskov Substitution Principle LSP)：</strong>子类应当可以替换父类并出现在父类能出现的任何地方。</p><p><strong>依赖倒置原则DIP(the Dependency Inversion Principle DIP)：</strong>程序要依赖于抽象接口而不能依赖于具体实现。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类，因为如果这样做的话任何一个下层模块的变动都会导致上层必须要被相应更改。正确做法应当由B定义一个抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。</p><p><strong>接口分离原则ISP(the Interface Segregation Principle ISP)：</strong>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来。</p><h3 id="Python中的面向对象编程"><a href="#Python中的面向对象编程" class="headerlink" title="Python中的面向对象编程"></a>Python中的面向对象编程</h3><h4 id="Python中的类-Class"><a href="#Python中的类-Class" class="headerlink" title="Python中的类(Class)"></a>Python中的类(Class)</h4><p>一个<code>类(Class)</code>会定义所有以它创建的对象，你甚至可以把类想象成一个对象工厂。举例来说，假设你有一只<code>牛头梗</code>，从<code>面向对象编程</code>的角度来看，一个<code>狗</code>的类中可能包含狗的一些特征，比如他的品种，眼色等。由于牛头梗是一只狗，那么我们就可以创建一个继承<code>狗</code>这个<code>类</code>特征的对象来定义牛头梗。<code>类</code>使用<code>方法函数(methods)</code>和<code>构造函数(constructors)</code>来创建并定义<code>对象(Objects)</code>。</p><h4 id="用户定义的方法-user-defined-methods-和特殊方法-special-methods"><a href="#用户定义的方法-user-defined-methods-和特殊方法-special-methods" class="headerlink" title="用户定义的方法(user-defined methods)和特殊方法(special methods)"></a>用户定义的方法(user-defined methods)和特殊方法(special methods)</h4><p><code>方法(methods)</code>是类中用以执行特殊任务的函数，Python将方法分成程序员编写的<code>用户定义方法(user-defined method)</code>和语言中自带的<code>特殊方法(special method)</code>。比如一个叫<code>狗</code>的<code>类</code>中可能有一个方法叫做<code>walk()</code>来供<code>狗</code>的对象调用，程序员编写这个方法来执行特殊的动作。</p><p>而<code>特殊方法</code>则被<code>双下划线(__)</code>包围的名字定义，比如说<code>__init__</code>。Python用这些特殊方法来加强类的功能性，其大多在后台工作并会在程序需要的时候被自动调用。程序员不能直接调用这些方法。举例来说，当你创建一个新的对象的时候，Python会自动调用<code>__new__</code>方法，而这又会调用<code>__init__</code>方法。</p><h4 id="构造函数-constructor"><a href="#构造函数-constructor" class="headerlink" title="构造函数(constructor)"></a>构造函数(constructor)</h4><p>构造函数是程序在创建对象时会调用的特殊方法，其在类中是被用来初始化对象数据的。以<code>狗</code>这个类举例，我们可以用这个类的构造函数去给每一个<code>牛头梗</code>对象特征赋值，<code>__init__</code>就是Python的构造函数。</p><h4 id="用代码来解释"><a href="#用代码来解释" class="headerlink" title="用代码来解释"></a>用代码来解释</h4><p>我们首先创建一个类，并且在这个类中定义一个<code>__init__</code>方法，而这个方法则初始化两个<code>属性(attribute)</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:                   </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,dogBreed,dogEyeColor</span>):</span><br><span class="line">  </span><br><span class="line">    self.breed = dogBreed       </span><br><span class="line">    self.eyeColor = dogEyeColor...</span><br></pre></td></tr></table></figure><p>这时我们已经有了一个<code>类</code>了，接下来我们以这个类创建<code>对象</code>，并且将<code>类</code>中的<code>属性</code>传递给这个<code>对象</code>。这时候我们就需要<mark class="hl-label red">self</mark> 这个magic word来将对象的属性绑定在其接收到的参数上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...Tomita = Dog(<span class="string">&quot;Fox Terrier&quot;</span>,<span class="string">&quot;brown&quot;</span>)...</span><br></pre></td></tr></table></figure><p>在上面这行代码中，我们创建了一个叫做<code>Tomita</code>的对象(这是这只狗的名字)，然后我们首先声明定义这个对象的类的名字(<code>Dog</code>)，然后将在<code>Dog类</code>的<code>__init__</code>中设定的两个属性分别设定为<code>Fox Terrier</code>和<code>brown</code>。然后<code>__init__</code>用<code>self</code>来将这两个以参数传回的值赋给对象的属性<code>self.breed</code>和<code>self.eteColor</code>。</p><p>然后要访问我们创建的对象的属性，我们只需要在对象名后用<code>.</code>接上相应的属性名，就可以访问这个对象的这个属性的值，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...<span class="built_in">print</span>(<span class="string">&quot;This dog is a&quot;</span>,tomita.breed,<span class="string">&quot;and its eyes are&quot;</span>,tomita.eyeColor)</span><br></pre></td></tr></table></figure><p>我们运行上面这段代码会得到这样的结果：</p><blockquote><p>This dog is a Fox Terrier and its eyes are brown</p></blockquote><p>Python中的构造函数也可以不输入参数，可以使用默认参数设定。如果一个构造函数不是必须输入参数的话，这个构造函数就叫<code>默认构造函数(default constructor)</code>。比如上面的<code>Dog类</code>如果写成默认构造函数形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:                </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dogBreed=<span class="string">&quot;German Shepherd&quot;</span>,dogEyeColor=<span class="string">&quot;Brown&quot;</span></span>): </span><br><span class="line">  </span><br><span class="line">    self.breed = dogBreed   </span><br><span class="line">    self.eyeColor = dogEyeColor</span><br></pre></td></tr></table></figure><p>可以注意到<code>__init__</code>中规定了两个参数的默认值<code>dogBreed</code>为<code>German Shepherd</code>而<code>dogEyeColor</code>为<code>Brown</code>，这时如果我们以<code>tomita = Dog()</code>这样不传递任何参数的方式创建对象，那么这个对象的属性就会被设定成默认的<code>German Shepherd</code>和<code>Brown</code>。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>通过这篇文章，我们首先理清楚了<code>面向过程编程</code>和<code>面向对象编程</code>二者的关系以及各自的利弊，前半部分实际适用于所有的编程语言，之后我们重点关注Python中面向对象编程的方式，并举例来说明一些比较难以理解的参数和设定(比如<code>__init__</code>和<code>slef</code>等)，搞懂了这些基础知识终于可以看懂一些大佬的代码到底在干什么了。</p>]]></content:encoded>
      
      
      <category domain="http://raylei.space/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</category>
      
      
      <category domain="http://raylei.space/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</category>
      
      <category domain="http://raylei.space/tags/Python/">Python</category>
      
      
      <comments>http://raylei.space/2022/02/23/5-What_is_object_oriented_programming/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[编程算法] 公司项目需要的自动化测试Selenium文档解读</title>
      <link>http://raylei.space/2022/02/21/4-Selenium_documentation_learning/</link>
      <guid>http://raylei.space/2022/02/21/4-Selenium_documentation_learning/</guid>
      <pubDate>Mon, 21 Feb 2022 10:22:00 GMT</pubDate>
      
      <description>本篇文章主要介绍了在公司项目中用Selenium做自动化测试的方法。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>基于刚进公司时接手的一个<code>自然语言处理</code>+<code>自动化测试</code>的项目，这篇文章我会主要覆盖Python的Selenium包的文档解读，由于在HKU时的毕业项目便涉及各种在线论坛的评论爬取，我对Selenium并不算陌生，但由于Selenium的内容功能是比较多的，本篇除了一些基础知识以外，我会重点关注与公司项目有关的部分。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>刚进公司的时候接手了一个前人的<code>自然语言处理</code>+<code>自动测试</code>项目。因为现在公司有一个由集团设定报价逻辑的报价系统，通常来说由代理或核保人员输入客户的相关资料便可以完成报价，但这个系统报价汽车险时要输入的资料非常繁琐，导致代理不愿意使用这个系统报价，影响报价率。考虑到这个系统中很多资料是没有意义的，因此前人建议代理直接填写车型排量司机年龄等必要资料，并用Python做了一个自动报价工具。</p><p>这个工具由两个大部分组成，第一个部分是自然语言处理，即使用<code>Cosine Similarity</code>算法将代理输入的车型信息与公司系统中的车型信息匹配，有机会我会再写一篇文章讲讲这部分。第二部分则是自动化测试，使用匹配到的车型信息利用Selenium自动填写资料并返回报价。前人对第一个部分的完成度是比较高的，因此我只是对代码<code>规范性</code>和<code>循环逻辑</code>稍作调整便可以获得较好的<code>文本匹配和稳定性</code>。但第二个部分他的测试显然是不够的（毕竟是未完成的项目），网站中有非常多的特殊情况例如某些资料未填写时其他资料将不会显示，司机年龄和驾龄都很小时会直接弹出错误信息不予报价，有时网站弹窗提示时需要先将该弹窗关闭才能继续操作等等。</p><p><strong>但由于代码本身涉及公司内部报价网站的架构，我<code>不会</code>在这里分享具体的代码或逻辑，因此本篇我会分享一些我在解决这些问题时通过<a href="https://selenium-python.readthedocs.io/index.html" title="Selenium with Python">Selenium with Python</a>学习到的知识。</strong></p><h2 id="Selenium文档解读"><a href="#Selenium文档解读" class="headerlink" title="Selenium文档解读"></a>Selenium文档解读</h2><p>在开始之前，我想先通过<a href="https://stackoverflow.com/questions/54459701/what-is-selenium-and-what-is-webdriver" title="What is selenium and what is webdriver">这个问题</a>下大佬们的回答介绍一下<code>Selenium</code>和<code>Webdriver</code>是什么。<code>Selenium</code>是一个适用于各种浏览器和平台的网页应用的<code>自动测试套装</code>，各个主要的浏览器提供商都已将<code>Selenium</code>作为其浏览器内部部分进行支持，而我使用的则是<code>Selenium</code>为<code>Python</code>接入提供的一个包。而<code>Webdriver</code>则顾名思义是一个连接你的脚本和浏览器的一个程序，其通过在浏览器中注入<code>Javascript</code>的方式来控制浏览器行为，你可以想象你通过你的Python脚本告诉这个<code>“司机”(driver)</code>如何开这个<code>&quot;车&quot;(browser)</code>。</p><h3 id="基本约定"><a href="#基本约定" class="headerlink" title="基本约定"></a>基本约定</h3><p>在介绍具体的函数之前，首先介绍一下Selenium API的一个基本约定。Selenium API 有一些属性(Attribute)是可调用的(即方式methods)，有一些属性是不可调用的(即特性properties)，所有可调用的属性都以圆括号结尾。如下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.current_url <span class="comment">#这是一个property,是一个值。具体来说是&quot;现在这个页面的URL&quot;。</span></span><br><span class="line">driver.close()<span class="comment">#这是一个method，是一个动作。具体来说是&quot;关闭当前窗口&quot;。</span></span><br></pre></td></tr></table></figure><h3 id="打开网页"><a href="#打开网页" class="headerlink" title="打开网页"></a>打开网页</h3><p>举例来说，当使用<code>webdriver.Chrome()</code>将<code>Chrome driver</code>设定为<code>实例(instance)</code>并将该实例赋值给<code>driver</code>时，使用<code>driver.get(“xx网址URL”)</code>，浏览器便会被打开并导航至该指定网址，需要注意的是<code>Webdriver</code>会等到网页完全加载完毕之后才将控制权返回你的脚本，也就是说在这个阶段你通常不用担心你的程序会急着在没有加载出来的网页中操作或找寻你要的东西，但如果网页使用了大量的<code>AJAX(Asynchronous JavaScript And XML</code>, 用于直接在已加载的网页中读取网络服务器数据)，那么driver可能无法判断网页是否完全加载，如果要确保网页完全加载可能需要使用selenium的<a href="#%E7%AD%89%E5%BE%85%E5%8A%A0%E8%BD%BD(Waits)">waits</a>函数。</p><h3 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h3><p>当我们进入了想要测试的网页之后，首先要解决的问题就是如何让driver找到你想要互动的元素，Selenium提供的方式非常丰富，包括<code>id, name, Xpath, link text, partial link text, tag name, class name甚至css selector</code>。</p><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>举例来说，如果我们有一个如下的网页：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;loginForm&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;continue&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Login&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;continue&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Clear&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span> Are you sure you want to do this?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;continue.html&quot;</span>&gt;</span>Continue<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;cancel.html&quot;</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么你可以分别通过下面这些方式定位你想要的各个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">login_form = driver.find_element_by_id(<span class="string">&#x27;loginForm&#x27;</span>) <span class="comment"># 通过id定位到表格</span></span><br><span class="line">username = driver.find_element_by_name(<span class="string">&#x27;username&#x27;</span>) <span class="comment"># 获得第一个name是“username”的元素</span></span><br><span class="line">username = driver.find_element_by_xpath(<span class="string">&quot;//form[input/@name=&#x27;username&#x27;]&quot;</span>) <span class="comment"># 第一个有子input元素名字是&#x27;username&#x27;的表格中的这个input元素</span></span><br><span class="line">continue_link = driver.find_element_by_link_text(<span class="string">&#x27;Continue&#x27;</span>) <span class="comment"># 第一个描述是&#x27;Continue&#x27;的链接</span></span><br><span class="line">continue_link = driver.find_element_by_partial_link_text(<span class="string">&#x27;Conti&#x27;</span>) <span class="comment"># 第一个描述包含&#x27;Conti&#x27;的链接</span></span><br><span class="line">p_element = driver.find_element_by_tag_name(<span class="string">&#x27;p&#x27;</span>) <span class="comment"># 第一个tag是p的元素</span></span><br><span class="line">content = driver.find_element_by_class_name(<span class="string">&#x27;content&#x27;</span>) <span class="comment"># 第一个class名是&#x27;content&#x27;的元素</span></span><br><span class="line">content = find_element_by_css_selector(<span class="string">&#x27;p.content&#x27;</span>) <span class="comment"># 第一个css selector符合给定条件的元素</span></span><br></pre></td></tr></table></figure><p>上面这些<code>find_element_by_*</code>的方式都只能用于找到页面中<code>第一个</code>出现的<code>符合条件</code>的元素，而如果把方式换成相应的<code>find_elements_by_*</code>那么它将以list的形式返回页面中符合条件的所有元素(但<strong>注意<mark class="hl-label red">没有</mark>  <code>find_elements_by_id</code></strong>, 因为一个html文件中<code>id只能是唯一</code>的)。</p><p>另外除了以上这些<code>public methods</code>以外，<code>Selenium</code>还提供了两个<code>private methods</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">driver.find_element(By.XPATH, <span class="string">&#x27;//button[text()=&quot;Some text&quot;]&#x27;</span>)</span><br><span class="line">driver.find_elements(By.XPATH, <span class="string">&#x27;//button&#x27;</span>)</span><br><span class="line"><span class="comment">## 除了By.XPATH外，像private methods也同样有By.ID, By.LINK_TEXT, By.PARTIAL_LINK_TEXT, By.NAME, By.TAG_NAME, By.CLASS_NAME, By.SELECTOR这些参数可以选择。</span></span><br></pre></td></tr></table></figure><p>需要注意的是，这两种方式并没有本质区别，因为<code>find_element_by_*</code>就是以<code>find_element</code>定义的，<a href="https://stackoverflow.com/questions/51035651/difference-between-public-and-private-selector-methods" title="Difference Between Public and Private Selector Methods">参考这里</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_element_by_xpath</span>(<span class="params">self, xpath</span>):</span><br><span class="line">    <span class="keyword">return</span> self.find_element(by=By.XPATH, value=xpath)</span><br></pre></td></tr></table></figure><h4 id="更多关于XPath"><a href="#更多关于XPath" class="headerlink" title="更多关于XPath"></a>更多关于XPath</h4><p>XPath通常来说是用得最多的定位元素的方式。XPath本身是一个专门用来定位XML文件中<code>节点(nodes)</code>的语言，由于<code>HTML</code>也可以由<code>XML</code>实现(<code>XHTML</code>), 这也使得Selenium用户可以用这个强大的语言来定位网页元素。XPath之所以用得比较多是因为理论上它可以定位到网页中的任何一个元素，无论它有没有被用<code>id</code>或<code>name</code>定义过。</p><p>XPath在selenium中使用也可以有两种方式，<code>绝对引用</code>或<code>相对引用</code>：</p><ul><li><code>绝对引用(不推荐)</code>：绝对引用的路径是从<code>root(html)</code>层开始往后推，虽然绝对引用可能可以更精确定位到想要引用的元素，但它的缺点却在于网页文件的一点点变动都会导致引用不正确。</li><li><code>相对引用</code>：相对引用是定位目标元素到它附近的(最好是母元素)有<code>id</code>或<code>name</code>属性的元素的相对路径，虽然有几率错过真正想找的元素(比如有两个<code>name</code>相同的元素)，但引用相对页面变动也更加稳定。</li></ul><p>举例来说，在上面这个[网页][#举例说明]中,我们可以使用很多不同的XPath来定位同一个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">login_form = driver.find_element_by_xpath(<span class="string">&quot;/html/body/form[1]&quot;</span>) <span class="comment"># 绝对引用定位form</span></span><br><span class="line">login_form = driver.find_element_by_xpath(<span class="string">&quot;//form[1]&quot;</span>) <span class="comment"># 文件中第一个form</span></span><br><span class="line">login_form = driver.find_element_by_xpath(<span class="string">&quot;//form[@id=&#x27;loginForm&#x27;]&quot;</span>) <span class="comment"># id是&quot;loginForm&quot;的form</span></span><br><span class="line">username = driver.find_element_by_xpath(<span class="string">&quot;//form[input/@name=&#x27;username&#x27;]&quot;</span>) <span class="comment"># 第一个form里面有name为“username”的input子元素</span></span><br><span class="line">username = driver.find_element_by_xpath(<span class="string">&quot;//form[@id=&#x27;loginForm&#x27;]/input[1]&quot;</span>) <span class="comment"># id是&quot;loginForm&quot;的form元素里的第一个input元素</span></span><br><span class="line">username = driver.find_element_by_xpath(<span class="string">&quot;//input[@name=&#x27;username&#x27;]&quot;</span>) <span class="comment"># 第一个name是&quot;username&quot;的input元素</span></span><br><span class="line">clear_button = driver.find_element_by_xpath(<span class="string">&quot;//input[@name=&#x27;continue&#x27;][@type=&#x27;button&#x27;]&quot;</span>) <span class="comment">#第一个name是&quot;continue&quot;且type是&quot;button&quot;的input元素</span></span><br></pre></td></tr></table></figure><p><a href="https://www.w3schools.com/xml/xpath_intro.asp" title="W3School XPath Tutorial">W3School</a>有更细致更全面的XPath有关的教程。</p><h3 id="等待加载-Waits"><a href="#等待加载-Waits" class="headerlink" title="等待加载(Waits)"></a>等待加载(Waits)</h3><p>自动测试项目中非常影响实际测试效果的一个因素就是这个部分了。Waits顾名思义就是让程序等待，Python的time包中有一个<code>sleep()</code>函数就可以做到这点，让程序暂停执行一段设定的时间。那么Selenium中的<code>·</code>有什么不同呢？<code>time.sleep()</code>是没有任何其他条件地让程序暂停一段时间，但Selenium中的<code>waits</code>却是令程序在某个条件被达成之前等一段设定的时间。换言之<code>一旦条件达成便立即执行</code>。Selenium有两种waits。</p><h4 id="显式等待-Explicit-waits"><a href="#显式等待-Explicit-waits" class="headerlink" title="显式等待(Explicit waits)"></a>显式等待(Explicit waits)</h4><p>使用显示等待会让程序在<code>给定条件</code>出现以前等待一段时间，超过这段时间或达成条件才进行下一步操作。默认设定下，程序会每隔<code>500毫秒</code>判断一次条件是否达成。以这段代码为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(<span class="string">&quot;http://somedomain/url_that_delays_loading&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.ID, <span class="string">&quot;myDynamicElement&quot;</span>))</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><p><code>expected_condition</code>是<code>selenium</code>预设的一些判断条件的函数，代码中的<code>EC.presence_of_element_located()</code>接受<code>locator</code>参数，而<code>locator</code>则是一个<code>(by, path)</code>的<code>元组(Tuple)</code>，这也是这里有两层括号的原因。当这个元素可以被定位后该函数会返回一个<code>true</code>(Boolean), 如果无法被定位这个函数则会返回<code>not null</code>。(<a href="https://www.selenium.dev/selenium/docs/api/py/_modules/selenium/webdriver/support/expected_conditions.html#visibility_of_element_located" title="Source code for selenium.webdriver.support.expected_conditions">参考这里</a>)</p><p><code>expected_condition</code>提供的预设好的网页条件还有以下这些：</p><ul><li>title_is</li><li>title_contains</li><li>presence_of_element_located</li><li>visibility_of_element_located</li><li>visibility_of</li><li>presence_of_all_elements_located</li><li>text_to_be_present_in_element</li><li>text_to_be_present_in_element_value</li><li>frame_to_be_available_and_switch_to_it</li><li>invisibility_of_element_located</li><li>element_to_be_clickable</li><li>staleness_of</li><li>element_to_be_selected</li><li>element_located_to_be_selected</li><li>element_selection_state_to_be</li><li>element_located_selection_state_to_be</li><li>alert_is_present</li></ul><p>如果这些预设好的条件无法满足你的需求，你还可以自己<code>定义等待条件</code>，参考<a href="https://selenium-python.readthedocs.io/waits.html" title="Selenium with Python (Waits)">文档</a>中的方法。</p><h5 id="一些容易有疑问的条件"><a href="#一些容易有疑问的条件" class="headerlink" title="一些容易有疑问的条件"></a>一些容易有疑问的条件</h5><p>上面这些预设的等待条件中有几个<code>非常相似</code>的条件，我特别拎出来讲一讲他们的区别：</p><ul><li>presence_of_element_located：只要元素在文件物件模型(DOM)<code>出现</code>便会返回true。</li><li>visibility_of_element_located：元素在DOM中<code>出现并且高度和宽度大于0 (visible)</code> 才会返回true。</li><li>element_to_be_clickable：元素需要<code>出现，可见并且可以互动</code>才会返回true。</li></ul><p>显然越下面的条件比上面越加严苛，如果你想让你的脚本按一个<code>button</code>，那么比起它的出现或者可见，你更应该关心它是不是已经<code>可以被按</code>了。其他的条件的具体解释也都可以参考<a href="https://www.selenium.dev/selenium/docs/api/py/_modules/selenium/webdriver/support/expected_conditions.html#visibility_of_element_located" title="Source code for selenium.webdriver.support.expected_conditions">源代码</a>中的写法和注释。</p><h4 id="隐式等待-Implicit-waits"><a href="#隐式等待-Implicit-waits" class="headerlink" title="隐式等待(Implicit waits)"></a>隐式等待(Implicit waits)</h4><p>隐式等待比显式等待在写代码的层面上更加简单，针对性也没有那么强。它只是让driver不能立马在DOM中定位到某项元素时，多等一段设定好的时间。隐式等待时间的默认设置为0，在一次<code>Webdriver</code>的使用中它只需要被<code>设定一次</code>。使用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>) <span class="comment"># seconds</span></span><br><span class="line">driver.get(<span class="string">&quot;http://somedomain/url_that_delays_loading&quot;</span>)</span><br><span class="line">myDynamicElement = driver.find_element_by_id(<span class="string">&quot;myDynamicElement&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h3><p>Selenium中可以用来操作元素的方式实在是太丰富了，我在这篇中只会提到我项目中会使用到的，也是最简单最基础的几个操作方法。</p><h4 id="点击元素"><a href="#点击元素" class="headerlink" title="点击元素"></a>点击元素</h4><p>非常直观，在你找到的元素后面调用<code>.click()</code>方式，便可以让driver尝试点击这个元素。</p><h4 id="填写输入"><a href="#填写输入" class="headerlink" title="填写输入"></a>填写输入</h4><p>当你定位到一个可以<code>input</code>的元素之后，可以使用<code>send_keys(&quot;whatevertext&quot;)</code>来将<code>引号</code>中的内容填入<code>Input元素</code>中。需要注意的一点是，<code>send_keys()</code>也可以发送其他如<code>回车(Keys.ENTER)</code>,<code>空格(Keys.SPACE)</code>等键盘上的功能键的指令 ,因此这个函数可以在任何元素上被调用。另外在文本框中文字不会将已有的文字清除，如果文本框中已经有文字，<code>send_keys()</code>只会在已有文字的后面附上新加的文字。因此通常使用此函数在文本框中输入文字时建议先使用<code>.clear()</code>将文字清除。</p><h4 id="选择表单"><a href="#选择表单" class="headerlink" title="选择表单"></a>选择表单</h4><p>Selenium使用户可以获取下拉表单的选项数据，并且使用<code>setSelected</code>来选中特定<code>OPTION标签</code>的元素。可用的选中方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line">select = Select(driver.find_element_by_name(<span class="string">&#x27;name&#x27;</span>)) <span class="comment"># 选中第一个name为&quot;name&quot;的元素</span></span><br><span class="line">select.select_by_index(index) <span class="comment"># 按序号(index)选中表单选项</span></span><br><span class="line">select.select_by_visible_text(<span class="string">&quot;text&quot;</span>) <span class="comment"># 按可见文字选中</span></span><br><span class="line">select.select_by_value(value) <span class="comment"># 按选项值选中</span></span><br></pre></td></tr></table></figure><p>其中<code>select_by_visible_text(&quot;text&quot;)</code>和<code>select_by_value(value)</code>的区别在于，想要选中给定的<code>&lt;option value=&quot;foo&quot;&gt;Bar&lt;/option&gt;</code>这个选项，需要使用<code>select_by_visible_text(&quot;Bar&quot;)</code>或者<code>select_by_value(&quot;foo&quot;)</code>。</p><p>另外，Select类中还有一些非常有用的公式如：</p><ul><li><code>all_selected_option</code>: 用于返回一个select标签下的所有已选项的list。</li><li><code>deselect_all()</code> : 清除所有已选项（仅对支持多选的元素有效）。</li><li><code>options</code>: 返回表单中所有可选项。</li></ul><h4 id="获取文字"><a href="#获取文字" class="headerlink" title="获取文字"></a>获取文字</h4><p>要从网页中爬取文字就一定要用到元素的<code>text</code>属性，该属性即可返回元素中的文字。</p><h2 id="Chrome开发者工具"><a href="#Chrome开发者工具" class="headerlink" title="Chrome开发者工具"></a>Chrome开发者工具</h2><p>虽然现在其实我对网页和网络的运作方式还处于一团迷雾的状态，但因为要爬取网页元素，也算是小小接触了<code>Chrome</code>中<code>按F12</code>就可以打开的<code>开发者工具</code>，要写关于网页的脚本这个界面是一定绕不开的。下面我会介绍两个我作为萌新<code>自己乱点摸索出来的</code>对爬虫或自动测试非常有用的两个功能。<strong>因为是自己摸索，所以很有可能走了弯路都不自知。如果有更好的方法，或者完整的玩转F12的指南手册，还希望各位大佬在评论区不吝赐教。</strong></p><h3 id="在网页文件中定位元素"><a href="#在网页文件中定位元素" class="headerlink" title="在网页文件中定位元素"></a>在网页文件中定位元素</h3><p>刚刚接触开发者工具的时候完全不知道如何在花里胡哨的html文件中找到网页中的某个元素，只知道在body里面一个一个往下找，对应着页面上的高亮一点一点往里点，后来才知道原来用Chrome的<code>这个功能</code>就可以快速定位到元素在html文件中的位置，非常方便。这是全世界都知道所以才没有被任何教程提及吗？</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/image-20220224195103131.png" alt="按下这个“定位”按钮再点想找的元素就可以定位到该元素在html中的位置"></p><h3 id="得到元素的XPath"><a href="#得到元素的XPath" class="headerlink" title="得到元素的XPath"></a>得到元素的XPath</h3><p>同样也是一个大概所有人都知道(所以没有在任何教程里见到提及)，但我是自己玩了老半天才偶然发现的功能。原来在开发者工具中右键点击元素，找到<code>复制→复制XPath</code>就可以直接得到这个元素相对路径的XPath，不确定Chrome的算法是怎样，但似乎这个复制XPath是在尽量选择<code>不会导致ambiguity</code>的方式引用。</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/image-20220224195027232.png" alt="对元素点击右键，然后依次按复制→复制XPath"></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>因为这个项目的机会，我对网页自动测试甚至是爬取网页的经验又增加了不少（当然我知道一般爬取网页的首选项肯定是<code>BeautifulSoup</code>，毕竟不经过浏览器互动的爬取会稳定不少，但现如今大部分的网页不用浏览器互动已经啥都爬不到了）。另外之后有时间我会再把项目前半部分关于<code>Cosine Similarity</code>文本相似度匹配的部分整理好再发一篇。</p>]]></content:encoded>
      
      
      <category domain="http://raylei.space/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</category>
      
      
      <category domain="http://raylei.space/tags/%E5%B7%A5%E4%BD%9C%E5%AD%A6%E4%B9%A0/">工作学习</category>
      
      <category domain="http://raylei.space/tags/Python/">Python</category>
      
      <category domain="http://raylei.space/tags/Selenium/">Selenium</category>
      
      
      <comments>http://raylei.space/2022/02/21/4-Selenium_documentation_learning/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[MS Office] 设计Excel报告模板动态展示前n项产品</title>
      <link>http://raylei.space/2022/02/19/3-excel-tool-develop-1/</link>
      <guid>http://raylei.space/2022/02/19/3-excel-tool-develop-1/</guid>
      <pubDate>Sat, 19 Feb 2022 05:03:53 GMT</pubDate>
      
      <description>记录最近工作中设计的一个Excel模板的设计到实现方法，工具目的是将导出的月度数据直接按产品YTD保费量排行展示。</description>
      
      
      
      <content:encoded><![CDATA[<p><font size=4><mark class="hl-label default">特别声明</mark> </font></p><mark class="hl-label default">本文中的出现的数据均经过随机扭曲处理，仅工具排版，逻辑与公式可供参考。</mark> <hr><h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>上周为公司的月度保费报告做了一些升级调整，主要是涉及产品保费量展示部分由以前的<code>静态展示固定产品保费</code>改为<code>按保费量动态展示产品排行</code>。其中涉及的Excel公式技巧包括但不限于<code>OFFSET应用</code>，<code>动态排名展示</code>，<code>合并单元格文字</code>等。</p><p>原工具中有三张表格，其中有互相参考验证数据正确性的<code>Tracking cells</code>，这里面我只讲稍微复杂一些的最后一张，且数据经过随机数扭曲，所以本文中展示的表格中的<code>Tracking cells</code>不会正常显示。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>该工具的最终目的是使用系统中生成的原始数据利用excel的公式功能自动整理计算数据并以要求形式展示。工具的目的是为了减少人力成本，因此一个原则是尽最大可能减少工具使用人在工具定板后使用时投入的成本，在此原则之上再尽力减少制作工具本身需要的时间和精力成本。本篇中我会分别介绍这个工具的版面设计以及从已有数据结构到需求的展示样式的逐步实现方法以及其中设计的一些可以广泛应用的小技巧。</p><h2 id="工具版面设计"><a href="#工具版面设计" class="headerlink" title="工具版面设计"></a>工具版面设计</h2><p>我设计Excel工具时一个习惯的guideline是将数据分为至少三个部分：</p><ol><li>不改变原数据的结构，以所得即所用的原则组成一个<code>数据输入区</code>，用这样的数据做成的工具可以减少该工具在后续使用中对使用人<code>“调整原数据”</code>的需求，从而降低使用成本。</li><li>将数据以标准形式整理并计算的<code>数据处理区</code>，这个部分通常会包含标准化的数据分类，这样做的目的是将原数据在该区域内透明地以标准化方式整理计算，以方便后续数据展示，并使各部分公式易于阅读和后续维护修改。</li><li>最后是数据的输出形式，即<code>数据展示区</code>，这个部分通常是按<code>数据使用人</code>的需求调整，也即在工具制作期间制作人通常不能控制的部分，我们最后的目的就是将处理好的数据按使用人需求展示。</li></ol><p>本工具的版面既是根据上述习惯排版：</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/img_20220220131551.png" alt="工具版面分为“数据输入区”，“数据处理区”和“数据展示区”三个部分"></p><h2 id="工具设计思路"><a href="#工具设计思路" class="headerlink" title="工具设计思路"></a>工具设计思路</h2><p>在开始设计工具之前需要理清最重要的两点，第一是到手的原数据结构，第二就是最终需要展示的信息。在这个案例中，我们提取出来的原数据为月度数据，包含信息有4列，分别是<code>险种</code>，<code>新/续业务</code>，<code>本/上年信息</code>以及<code>保费</code>本身。其中每个险种分别会有本&#x2F;上年的新&#x2F;续业务保费，这样<code>2x2=4</code>种的组合。因此可以知道标准格式中只需要包含<code>所有可能险种数x4</code>行既可以展示所有可能的输入组合。</p><p>此时开始分析需要展示的信息，所需展示的信息可以分为3部分：首先是将险种按当前年度总保费的大小排名并展示前8个险种，将此之外的保费信息加总归入<code>Other</code>类。其次将各月保费按需求的时间维度分组加总展示(如月度，季度，半年度，当前合计等)。最后只需要动态地将未展示出来的险种名合并展示作为备注即可。</p><p>为满足该需求，我的设计是将保费性质信息作为标准化维度放在数据处理区的最左边并以月份为列名排列所有数据输入区的数据，排列后在处理区将各险种按当年保费(新续业务加总)排出大小并标识，最后在展示区以<code>OFFSET</code>为引用处理区不同月度数据的方法，以降低制作工具本身所需的时间，提高公式的<code>可读性</code>和<code>修改弹性</code>。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>此章中我不会事无巨细介绍所有出现的技巧，如果想要详细了解建议在最后链接中下载该工具样本自己研究，我的公式应该都是trackable的，这里我只会分别介绍几个可以广泛应用到其他需求中的方法和公式。</p><h3 id="如何跳行-x2F-列引用数据"><a href="#如何跳行-x2F-列引用数据" class="headerlink" title="如何跳行&#x2F;列引用数据"></a>如何跳行&#x2F;列引用数据</h3><p>这是制作该工具时我使用的第一个小技巧，答案非常简单，既是<code>OFFSET</code>。在工具中可以看到，原数据中每月数据有4列信息，而数据处理区中我们只希望每1列展示一个月信息，这样导致的问题是如果不使用OFFSET而将处理区中的<code>SUMIFS</code>公式直接向右复制，则会使每个引用信息仅向右移动1列，从而导致<code>引用区域错位</code>。因此我们需要左边处理区每向右移动1列，公式中的引用区同步向右移动4列，才能将所有引用信息移动至原数据中的<code>下月中相应区域</code>。</p><p>以处理区中最左上角的公式为例：</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/image-20220220151308158.png" alt="=SUMIFS(OFFSET($V$30:$V$177,,E$28,,),OFFSET($U$30:$U$177,,E$28,,),$D30,OFFSET($T$30:$T$177,,E$28,,),$C30,OFFSET($S$30:$S$177,,E$28,,),$B30)/1000000"></p><blockquote><p>&#x3D;SUMIFS(OFFSET($V$30:$V$177,,E$28,,),OFFSET($U$30:$U$177,,E$28,,),$D30,OFFSET($T$30:$T$177,,E$28,,),$C30,OFFSET($S$30:$S$177,,E$28,,),$B30)&#x2F;1000000</p></blockquote><p>该公式除去OFFSET便是非常简单的SUMIF公式如下，即将原数据中的信息按标准模板加总排列：</p><blockquote><p>&#x3D;SUMIFS($V$30:$V$177,$U$30:$U$177,$D30,$T$30:$T$177,$C30,$S$30:$S$177,$B30)&#x2F;1000000</p></blockquote><p>那么OFFSET是怎么用的呢？OFFSET函数本身的作用就是以公式参数的方法来移动改变引用区域，他的参数如下：</p><blockquote><p>&#x3D;OFFSET(Reference, rows, cols, [height],[width])</p></blockquote><p>其中<code>Reference</code>为引用的区域，后面的四个参数分别代表在<code>Reference</code>的基础上要移动的<code>行数</code>，<code>列数</code>，<code>高度</code>，<code>宽度</code>，<code>正数代表向右/向下，负数反之</code>。</p><p>以我们的公式为例，<code>OFFSET($V$30:$V$177,,E$28,,)</code>即代表将<code>$V$30:$V$177</code>移动<code>E$28</code>标注的列数(此处为0，即不移动)，其他参数未设置则用<code>,</code>隔开。到这里我只需要将每个月的列上以等差数列向右排列引用所需移动的列数，即可以一个公式为每个月需要引用的原数据找到正确的引用位置。同样的方法在<code>数据展示区</code>也大量的使用，因此可以用一个公式以改变最少参数的方法来填入表格中。</p><p>OFFSET这样的公式非常明显，是为了减轻工具制作和维护的成本而存在的，因为用到不同的公式越少，后期维护时就越简单，毕竟这里你也可以选择人手将不同月份的引用区域拖动到他们合适的位置，不过制作和维护的成本将大大增加。</p><h3 id="仅对当前第一次出现的元素计算"><a href="#仅对当前第一次出现的元素计算" class="headerlink" title="仅对当前第一次出现的元素计算"></a>仅对当前第一次出现的元素计算</h3><p>我们想要将产品按当前合计保费量排名，也即将当年的新&#x2F;续保费加总并排名，但我们却不能直接使用SUMIF加总，因为按照我的版面设计，如果直接全部加总排行时每个产品会有两个相同的保费，从而影响排行名次。因此我们要想办法使每个产品名后仅出现一个加总保费。好在我们的数据处理区是标准化设计，上半部分全部是当年数据且每个险种按NB-RN的顺序规律排列。因此我们可以是用公式从上至下仅仅对该元素第一次出现时进行计算。</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/image-20220220152214570.png" alt="=IF(COUNTIF($B$30:$B30,$B30)=1,SUM(OFFSET(E30:P30,,,2,)),0)"></p><blockquote><p>&#x3D;IF(COUNTIF($B$30:$B30,$B30)&#x3D;1,SUM(OFFSET(E30:P30,,,2,)),0)</p></blockquote><p>这个公式分为两个部分，其中<code>IF</code>部分为重点，即判断语句<code>COUNTIF($B$30:$B30,$B30)=1</code>。需要注意其中<code>$B$30:$B30</code>中<code>:</code>后的<code>B30</code>仅仅固定了列数，因此该公式在下拉时该引用区域也会相应拉长。这就使得这个<code>COUNTIF</code>公式可以实现计算<code>从上到下到目前为止B列该元素出现过的次数</code>。而此时将判断语句写为<code>该COUNTIF为1</code>则表示从上到下第一次出现这个元素时，则计算后面的<code>SUM(OFFSET(E30:P30,,,2,))</code>，否则返回0。</p><p>这个<code>SUM</code>函数中的<code>OFFSET</code> 的<code>height</code>参数被设置为<code>2</code>，因此加总包括该引用处在内的向下共<code>2</code>个单元格。以此实现每个出现的产品进行一次BN和RN的数值加总。</p><h3 id="将出现过的数字按大小排名"><a href="#将出现过的数字按大小排名" class="headerlink" title="将出现过的数字按大小排名"></a>将出现过的数字按大小排名</h3><p>上一步中我们已经得到了每一个产品的当年总保费，那么使用<code>RANK.EQ</code>函数既可以对保费量进行排名从而使每个险种得到一个相应的排名。本来此时在展示区左边我只需要手动输入1,2,3便可以自动展示排名为1,2,3的产品名，但此处有一个特殊需求，那就是由于下架，要将PAM这个产品的除出排名，直接并入Other分类。但由于PAM还是有续保保费，因此它每个月的保费量也并不是固定的，虽然我可以使用<code>IF</code>函数将<code>PAM</code>的排名直接设定为<code>999</code>，但我们依然需要一个可以动态将已有数字从小到大排列的方法，否则会出现的问题是假设<code>PAM</code>实际排名是<code>6</code>，但它被公式设定为排名<code>999</code>，这会导致手动输入的<code>6</code>后面将没有可以引用的数据，我们需要自动将上方排列设置为4,5,7来跳过排名为<code>6</code>的<code>PAM</code>。</p><p>我想到的办法是SMALL公式：</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/image-20220220153736776.png" alt="=SMALL($A$30:$A$103,ROW(A2)/2)"></p><blockquote><p>&#x3D;SMALL($A$30:$A$103,ROW(A2)&#x2F;2)</p></blockquote><p>该公式可用参数为<code>SMALL(array,k)</code>，其作用既是返回该数据中第<code>K</code>个最小值，同理的还有<code>LARGE</code>函数。</p><p>在这里的使用方法既是展示<code>在数据处理区中出现的排行数中排行第ROW(A2)/2的最小值</code>，使用<code>ROW(A2)</code>就可以使该<code>K</code>值随着公式的下拉而增加，<code>ROW(A2)</code>返回的是<code>A2</code>单元格的行数，也即<code>2</code>。该数值<code>/2</code>则可以使每个数值出现两次，以此匹配每个险种名显示两次以匹配NB和RN这两行数据，因为<code>A2</code>和<code>A3</code>两行的计算结果分别是<code>1</code>和<code>1.5</code>，都会被公式向下取整认定为<code>1</code>，同理如果希望数值重复<code>N</code>次，则<code>/N</code>即可实现，注意不要让商小于<code>1</code>。</p><h3 id="IF公式的数组应用"><a href="#IF公式的数组应用" class="headerlink" title="IF公式的数组应用"></a>IF公式的数组应用</h3><p>最后的一个展示要求是将Other分类中，也即保费排名未在前八位但本年有保费收入的产品名备注出来:</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/image-20220220170737896.png" alt="=CONCAT(&quot;*The Other Products contains &quot;,IF(($Q$30:$Q$103&lt;&gt;0)*($A$30:$A$103&gt;MAX($A$6:$A$21)),LEFT($B$30:$B$103,3)&amp;&quot;, &quot;,&quot;&quot;))"></p><blockquote><p>&#x3D;CONCAT(“<em>The Other Products contains “,IF(($Q$30:$Q$103&lt;&gt;0)</em>($A$30:$A$103&gt;MAX($A$6:$A$21)),LEFT($B$30:$B$103,3)&amp;”, “,””))</p></blockquote><p>这个公式中的主要知识点便是<strong>IF公式的数组应用</strong></p><blockquote><p>IF(($Q$30:$Q$103&lt;&gt;0)*($A$30:$A$103&gt;MAX($A$6:$A$21)),LEFT($B$30:$B$103,3)&amp;”, “,””)</p></blockquote><p>该公式的<code>重点</code>，也是<mark class="hl-label red">难点</mark> ，便是条件语句部分的<code>($Q$30:$Q$103&lt;&gt;0)*($A$30:$A$103&gt;9)</code>,此处的乘法操作是为了筛选出该范围中同时满足两个条件的行数，因为Excel中所有<code>1等价于TRUE，0等价于FALSE</code>，因此此时两个判断语句的结果每行相乘，只有两个判断均为<code>TRUE</code>时，产生的结果才是<code>TRUE</code>。（0乘0或0乘1都是0这个很好理解吧）这时<code>IF</code>函数返回的数组既是所有同时满足这两个条件的行(两个1相乘才返回1)，即当年总保费不为0且排名大于展示区所有排名的产品代码。最后用<code>CONCAT</code>函数便可以将数组返回的数据组合在一个单元格中。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这个看似简单的数据工具却花了我将近一天的时间设计调整，其中的公式都是我自己根据自己的知识储备自己琢磨出来的，因此很难说参考了哪些资料，如果一定要说的话大概就是<code>Michael Alexander</code>的<code>Excel 2019 Bible</code>吧，当年入坑Excel的参考书就这一本，但也非常足够了。</p><p>该工具的一个副本放在这里,有兴趣可以看看：<a href="/attachment/Product_ranking.xlsx">下载链接</a></p>]]></content:encoded>
      
      
      <category domain="http://raylei.space/categories/MS-Office/">MS Office</category>
      
      
      <category domain="http://raylei.space/tags/Excel/">Excel</category>
      
      <category domain="http://raylei.space/tags/%E5%B7%A5%E4%BD%9C%E5%AD%A6%E4%B9%A0/">工作学习</category>
      
      
      <comments>http://raylei.space/2022/02/19/3-excel-tool-develop-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[博客维护] 使用Typora和PicGo简单便捷地编辑带图博文</title>
      <link>http://raylei.space/2022/02/12/2-typora_picgo_config/</link>
      <guid>http://raylei.space/2022/02/12/2-typora_picgo_config/</guid>
      <pubDate>Sat, 12 Feb 2022 09:50:16 GMT</pubDate>
      
      <description>本文介绍了如何使用Markdown编辑器Typora及配套图片管理软件PicGo便捷地编辑和管理博文。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>网站已经搭好了，但是怎么样编辑并且发布文章呢？我们知道网站中的文章都是作者按照排版需求使用Markdown语法写出.md后缀文件(既Markdown文件)并以此生成相应的html文件供浏览器读取展示，而插入图片的方法却只能使用路径引用的方法非常繁琐。本文将介绍在Hexo框架下发博文的方法，以及如何使用md编辑器<a href="https://typora.io/" title="Typora Website">Typora</a>与图床管理软件<a href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#picbed-tcyun" title="PicGo-Core Documentation">PicGo</a>来简单便捷地编辑图文。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="创建博文"><a href="#创建博文" class="headerlink" title="创建博文"></a>创建博文</h2><p>先介绍一些在Hexo中发文的基础知识。</p><h3 id="Hexo框架下博文的保存"><a href="#Hexo框架下博文的保存" class="headerlink" title="Hexo框架下博文的保存"></a>Hexo框架下博文的保存</h3><p>在我们安装的<a href="https://hexo.io/docs/setup" title="Setup for Hexo">Hexo</a>的根目录下与Hexo有关的分别是下面四个，他们的作用分别如下：</p><ul><li><strong>scaffolds:</strong> 模板文件夹，保存了草稿，页面和文章这三类md文件的模板，新建的该类文件内容将与模板一致。</li><li><strong>source:</strong> 保存网站内容的文件夹，其中的<code>_post</code>子文件夹即是保存md格式博文的文件夹。<code>source文件夹</code>中的所有可渲染文件(例如markdown和html)都将被渲染并被放入<code>public文件夹</code>，其他类型文件则会被直接复制。</li><li><strong>public:</strong> 保存网站原码的文件夹，这个文件夹中的内容将被推出并托管在<code>GitHub Pages</code>上形成网页。</li><li><strong>theme:</strong> 保存Hexo主题文件的文件夹，Hexo会同时基于网站内容和主题文件来生成相应的静态文件。</li></ul><p>也就是说我们的博文其实就是保存在<code>source/_post</code>文件夹中的md文件，即创建txt文件后改后缀成md，只要在文件开头—分隔符内(即<code>front-matter</code>)写上必要的配置如标题，日期等，这个md文件便会被识别渲染为一篇博文。</p><h3 id="Hexo新建页面-x2F-博文命令"><a href="#Hexo新建页面-x2F-博文命令" class="headerlink" title="Hexo新建页面&#x2F;博文命令"></a>Hexo新建页面&#x2F;博文命令</h3><p>即使只要放入md文件即可被渲染成网页，Hexo依然提供了更方便的创建新页面或博文的方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt; <span class="comment">#layout若不填则自动按post模板创建，title将同时被用于文件名和frontmatter中的title参数</span></span><br></pre></td></tr></table></figure><p>hexo命令创建三类文件的方式分别如下：</p><ul><li><strong>Page(页面)</strong>: 在<code>source</code>文件夹下创建一个指定名称的路径，并在里面创建一个index.md文件，该文件中内容将显示在页面上。</li><li><strong>Draft(草稿)</strong>: 在<code>source/_drafts</code>文件夹中创建一个草稿，该文件不会被展示在页面上，但可以被用<code>hexo pubilish [layout] &lt;filename&gt;</code>命令发布。</li><li><strong>Post(博文)</strong>: 若<code>new</code>命令没有指定<code>layout</code>则将默认创建该类型，此类型被创建在<code>source/_post</code>文件夹中，会被直接渲染为博文。</li></ul><h2 id="使用Typora和PicGo编辑博文"><a href="#使用Typora和PicGo编辑博文" class="headerlink" title="使用Typora和PicGo编辑博文"></a>使用Typora和PicGo编辑博文</h2><p>知道了Hexo下发博的基本知识，现在终于来到正题，如何方便快捷地编辑一篇图文并茂的博文呢？我的选择是Typora与其绑定的图床管理软件PicGo Core。</p><h3 id="Typora是什么"><a href="#Typora是什么" class="headerlink" title="Typora是什么"></a>Typora是什么</h3><p>Typora是一款专门用来编辑Markdown文件的编辑软件，他的最大特点便是”所见即所得“。在这个软件中你可以使用markdown语法来调整你的文章展示，而你写下的格式语法会被Typora直接转换为渲染后的效果。这样作者就可以很方便地一边编辑一边调整最终成稿。</p><h3 id="PicGo是什么"><a href="#PicGo是什么" class="headerlink" title="PicGo是什么"></a>PicGo是什么</h3><p>简单来说，PicGo是一个用于快速上传图片至图床并获取图片URL链接地工具。一直以来在md文件中插入并管理图片都是一个非常麻烦的工作，你需要将你需要使用的图片放在本地或图床上，并在md文章中引用这些地址来实现图片地展示。但现在Typora中置入了PicGo Core的工具让你可以以可视化的方式简单方便地插入图片在你的博文中。</p><h3 id="具体如何配置"><a href="#具体如何配置" class="headerlink" title="具体如何配置"></a>具体如何配置</h3><p>虽然PicGo支持的图床相当多，但大部分图床都有各种各样的限制或收费。而我个人选择的则是GitHub作为我的图床，因为在建站时创建的远程仓库刚好可以直接拿来用作图床，除了文章内使用的图片，其他包括top_img或封面等都可以很方便地上传至这些远程仓库用来引用。</p><h4 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a>配置Typora</h4><p>从Typora的上方选项中依次打开<code>格式→图像→全局图像设置</code>，然后会进入下图的界面，按图片中的设置配置打勾：</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/image-20220214215927465.png" alt="按图中方式配置"></p><p>选择插入图片时<code>上传图片</code>，下方下拉选单选择<code>PicGo-Core(command line)</code>，这时可以直接<code>下载或更新</code>。安装好<code>PicGo</code>后就需要配置图床了。</p><h4 id="配置图床"><a href="#配置图床" class="headerlink" title="配置图床"></a>配置图床</h4><p>为方便我选择的是GitHub的远程仓库作为我的图床，大家可以按照PicGo的<a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A" title="PicoGo Configuration on GitHub图床">官方文档</a>生成该远程仓库的token用于使PicGo可以获得访问该仓库的权限。获得这个token之后我们就可以开始填写PicGo的配置文件，用户可以在命令行中输入<code>picgo set uploader</code>来进入交互式命令行：</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/image-20220214234833095.png" alt="image-20220214234833095"></p><p>用方向上下键移动，回车选中github，然后命令行会分别要求你输入需要的参数以生成配置文件，填写完成后在命令行中继续输入<code>picgo use uploader</code>并选择刚刚配置的uploader来完成配置。按要求完成好后生成的配置文件如下，当然你也可以直接按Typora中的<code>打开配置文件</code>按钮或直接去到系统用户目录下<code>.picgo/config.json</code>中手动填入配置，但鉴于出错的可能性比较大，更推荐自动生成配置文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;transformer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;path&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;github&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;username/reponame&quot;</span><span class="punctuation">,</span><span class="comment">//填入你的github仓库的用户名/仓库名</span></span><br><span class="line">      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;branchname&quot;</span><span class="punctuation">,</span> <span class="comment">//填入分支名</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tokentokentoken&quot;</span><span class="punctuation">,</span><span class="comment">//填入github token</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;post_img/&quot;</span><span class="punctuation">,</span><span class="comment">//填入需要上传到的文件夹路径</span></span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时你就已经在Typora中配置好了图床，按一下Typora中的<code>验证图片上传选项</code>按钮，显示验证成功，这时你就可以直接截图粘贴至你正在Typora中编辑的博文，Typora会自动帮你完成上传图片至图床并返回图片链接至你粘贴图片的位置的操作。</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/image-20220215000247746.png" alt="image-20220215000247746"></p><h4 id="使用图床"><a href="#使用图床" class="headerlink" title="使用图床"></a>使用图床</h4><p>除了使用Typora的自动上传功能以外，我们也可以直接手动利用我们的GitHub来作为我们的图床使用，在本地仓库中放入需要使用的文件或图片，然后对他们使用 <code>add commit push</code>三部曲推至远程仓库(由于本地仓库不会自动更新Typora上传至远程仓库中的图片，因此如有改动，在add前还需要先将远程仓库的改动pull至本地仓库，以免报错)，然后便可以使用<code>raw.githubusercontent.com</code>后接文件在github中的路径便可以直接访问该文件的raw (即未处理版本)文件。</p><hr><p>以下内容为2022年2月19日补充</p><h2 id="使用Jsdelivr加速图床"><a href="#使用Jsdelivr加速图床" class="headerlink" title="使用Jsdelivr加速图床"></a>使用Jsdelivr加速图床</h2><p>由于一直在香港且只在自己的电脑上测试，并没有意识到GitHub作为图床使用的一个重要缺点，那就是当内地用户访问网站时使用<code>raw.githubusercontent.com</code>链接会导致图片裂开…在苦恼了几分钟以为要把所有链接换成其他内地付费的图床时我找到了<code>JSDelivr</code>这个解决办法。</p><p>其实使用<code>JSDelivr</code>的链接是我刚刚开始查找图片链接方法时就注意到了的，但由于发现<code>GitHub</code>的raw链接可以实时展现图片而不需要release版本blabla，也就没有继续看稍微麻烦一些的<code>JSDelivr</code>，现在看来是福不是祸，是祸躲不过啊。</p><h4 id="Jsdelivr是什么？"><a href="#Jsdelivr是什么？" class="headerlink" title="Jsdelivr是什么？"></a>Jsdelivr是什么？</h4><p>参考<a href="https://www.dazhuanlan.com/charmsky/topics/1636035" title="前端 使用JSDelivr加速加载Github资源">这篇文章</a>我们知道<code>JSDelivr</code>是<code>内容分发网络(Content Delivery Network, i.e. CDN)</code> 的提供商之一，简单来说既是将特定网站的资源分布至各地网络，然后该资源被请求时即从距离请求最近的服务器回应该请求，从而达到加速资源访问的目的。</p><h4 id="如何在Typora中设置JSDelivr？"><a href="#如何在Typora中设置JSDelivr？" class="headerlink" title="如何在Typora中设置JSDelivr？"></a>如何在Typora中设置JSDelivr？</h4><p>首先要注意的是前文中提到<code>PicGo</code>的配置文件中有一个之前未提及的<code>customUrl</code>项，设定该项即可将上传图片后返回的链接自定义到<code>JSDelivr</code>的链接从而使用其服务。具体来说是改成：</p><blockquote><p>“customUrl”: “https:&#x2F;&#x2F; cdn.jsdelivr.net&#x2F;gh&#x2F;用户名&#x2F;仓库名”   #注意去掉网址中间的空格</p></blockquote><p>经过我的测试，发现在Typora中粘贴图片可以正常上传至<code>GitHub仓库</code>，但返回的链接却不能正确显示图片。这个原因我猜测是因为是我们没有将上传的图片release，因此这时JSDelivr还无法获得获取我们上传的资源，按照<a href="https://www.cnblogs.com/yu-du-chen/p/12109065.html" title="jsdelivr的使用">这篇文章</a>的方式发布后，图片就可以用<code>JSDeliver</code>的链接访问了。</p><p>最后一点小备注，在release步骤中填写的Tag也就是版本号，如果在仓库名和文件夹名中间加入这个Tag名，即可访问该版本的资源，如果不加这个版本号则是默认访问最新的版本资源。</p><blockquote><p>https:&#x2F;&#x2F; cdn.jsdelivr.net&#x2F;gh&#x2F;用户名&#x2F;仓库名&#x2F;<mark class="hl-label default">版本号</mark> &#x2F;文件路径   #注意去掉网址中间的空格</p></blockquote><hr><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>现在作为完全小白的我终于可以快乐而没有顾忌地发文章了，一切麻烦的事情都交给Typora。</p>]]></content:encoded>
      
      
      <category domain="http://raylei.space/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/">博客维护</category>
      
      
      <category domain="http://raylei.space/tags/Blog/">Blog</category>
      
      <category domain="http://raylei.space/tags/GitHub/">GitHub</category>
      
      <category domain="http://raylei.space/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</category>
      
      <category domain="http://raylei.space/tags/Typora/">Typora</category>
      
      <category domain="http://raylei.space/tags/PicGo/">PicGo</category>
      
      
      <comments>http://raylei.space/2022/02/12/2-typora_picgo_config/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[博客维护]基于Hexo框架搭建个人网站的实现记录</title>
      <link>http://raylei.space/2022/02/10/1-blog_setup_notes/</link>
      <guid>http://raylei.space/2022/02/10/1-blog_setup_notes/</guid>
      <pubDate>Thu, 10 Feb 2022 14:50:59 GMT</pubDate>
      
      <description>本文介绍了我跟随枫叶的详细教程成功搭建本网站的过程中的一些心得以及需要注意的点。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>从很久以前就想搭一个自己的网站，分享并且记录自己的一些日常工作和学习的过程和成果，此篇作为我的第一篇文章，就先分享一下我跟随<a href="https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg" title="从零开始搭建个人博客（超详细)">枫叶</a>的详细教功搭建本博客网站的一些心得体会。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本网站的搭建过程与枫叶教程中的基本一致，下面我就分篇讲一讲我作为一个“网络”小白在读教程的过程中遇到的一些问题，以及查询资料后我的理解。</p><h2 id="关于第二篇Git安装的问题"><a href="#关于第二篇Git安装的问题" class="headerlink" title="关于第二篇Git安装的问题"></a>关于第二篇Git安装的问题</h2><p>Git本身是一个免费开源的分布式版本控制系统(Distributed version control system), Git的主要作用是我们通过此版本控制系统提交文件至仓库，由该系统为提交的文件打上版本号，然后每次提交仓库时根据版本号知道哪些文件需要更新哪些可以不用改动。需要记录的几个定义，需要强调的是以下基于我查到的资料和我自己的理解，有理解不对的地方还请大神指正：</p><ul><li>本地仓库与远程仓库：分别指建立在本地和互联网服务器内的文件夹</li><li>分布式与集中式版本控制系统：分布式系统（如Git）同时具有本地及远程仓库，提交文件时先提交至本地仓库，有网络时再提交至服务器上的远程仓库。集中式系统（如SVN）只配有远程仓库，提交文件时直接提交到远程仓库。</li><li>在此步骤中，GitHub既是远程仓库，是一个网络文件夹。我们主要使用Git作为同步本地仓库和远程仓库的工具。</li></ul><h2 id="关于第三篇绑定GitHub并提交文件"><a href="#关于第三篇绑定GitHub并提交文件" class="headerlink" title="关于第三篇绑定GitHub并提交文件"></a>关于第三篇绑定GitHub并提交文件</h2><p>跟随步骤进行时有两点需要注意：</p><h3 id="Git的username和email的配置"><a href="#Git的username和email的配置" class="headerlink" title="Git的username和email的配置"></a>Git的username和email的配置</h3><p>首次提交文件时需要向远程仓库声明本机器的名字和Email地址，即使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;yourusername&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;youremailaddress@xxx.com&quot;</span></span><br></pre></td></tr></table></figure><p>根据<a href="https://careerkarma.com/blog/git-config/" title="How to Set Up Git Using git config">这篇文章</a>的描述，这个username可以是任何你想要附在你的提交文件上的一个“标记”，它不需要和你的版本控制用户名（例如你的GitHub用户名）一致。之所以要在首次提交之前输入这个信息就是为了给你的提交打上“标记”, 一旦你的提交被创建，它的“著作权”就已经和你填写的这两条信息绑定，不能再被更改。</p><p>此处以我自己的理解是该名字和Email地址其实对于我们真正要做的事情并没有实质作用或影响，只不过是向远程仓库提交了一个象征这个本地仓库的一个符号，提交后即可以使用下方命令查看配置是否成功上传。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config -l</span><br></pre></td></tr></table></figure><p>之所以强调要查看这个配置的原因是因为在枫叶的教程中给出的代码有<strong>少许错误</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/image-20220210235741955.png" alt="教程中的代码没有带空格"></p><p>没有这个空格不会有任何报错，同时也不会有任何效果，我当时因为不知道这个小错误，还以为username与email都成功设置了，导致Git一直无法成功commit而找不到原因，需要注意。</p><h3 id="从Master换成Main的掩耳盗铃"><a href="#从Master换成Main的掩耳盗铃" class="headerlink" title="从Master换成Main的掩耳盗铃"></a>从Master换成Main的掩耳盗铃</h3><p>枫叶教程中多次提及的GitHub的默认分支Master，<a href="https://blog.csdn.net/j3T9Z7H/article/details/108898310" title="今天开始，GitHub将启用main作为默认分支名，master将成为历史！">查询</a>后发现原来这个默认的Master分支已经在2020年10月1日起被GitHub改成了Main，其原因竟是因为要避讳可能引起人们联想到奴隶制的词汇，为了这种自欺欺人的原因导致多少人的麻烦。</p><h4 id="push文件时的命令"><a href="#push文件时的命令" class="headerlink" title="push文件时的命令"></a>push文件时的命令</h4><p>回到正题，因为分支名的改动，文件commit至本地仓库后应使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin main</span><br></pre></td></tr></table></figure><p>将本地仓库提交至远程仓库，这其中origin是远程主机(即GitHub)的名字,而main则是我们仓库的默认分支名。</p><h4 id="初始化本地仓库时要做的修改"><a href="#初始化本地仓库时要做的修改" class="headerlink" title="初始化本地仓库时要做的修改"></a>初始化本地仓库时要做的修改</h4><p>在实际操作中我还发现了这个改动导致git隐藏的一个地雷，那就是当我们用枫叶第三篇博客中提到的第二种git方法提交文件时，使用<code>git init</code>将不会初始化到我们想要的main分支，而是默认创建了master分支。这将直接导致我们之后使用<code>git push origin main</code>推至远程仓库时会报错，因为我们的本地仓库根本就不是main。</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/image-20220213115508276.png" alt="image-20220213115508276"></p><p>这时我们要将这个本地仓库分支名改成我们想要推至的远程仓库，并且最好顺道把<code>git init</code>的默认分支也改成main，毕竟GitHub的默认分支都已经改成main了。然后你就可以继续按照教程快乐上传各种文件了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -M main <span class="comment">#这个命令可以将你当前所在的本地仓库分支名改成-M后面这个参数&quot;main&quot;</span></span><br><span class="line">$ git config --global init.defaultBranch main <span class="comment">#将默认分支名改成main，可以用git config -l查看是否更改成功</span></span><br></pre></td></tr></table></figure><h3 id="为什么要提交到GitHub"><a href="#为什么要提交到GitHub" class="headerlink" title="为什么要提交到GitHub?"></a>为什么要提交到GitHub?</h3><p>我们之所以要将文件提交至GitHub的远程仓库其实是因为其提供的一项服务<a href="https://docs.github.com/en/pages" title="GitHub Pages Documentation">GitHub Pages</a>， 这项服务使用户可以创建和托管其自己的个人网站，每个GitHub账号只允许创建一个网站，这也是我们要用创建名称为<code>“用户名.github.io”</code>的仓库这样的方式来启用这项服务的原因。</p><h2 id="关于第五篇安装node-js和Hexo"><a href="#关于第五篇安装node-js和Hexo" class="headerlink" title="关于第五篇安装node.js和Hexo"></a>关于第五篇安装node.js和Hexo</h2><p>node.js简单来说就是JavaScript的一种运行环境，而npm则是node.js的包管理器 (package manager)，使用npm可以自动根据各个需要模块的依赖关系快速下载安装需要的所有依赖的包并管理，本篇中安装node.js的直观原因就是为了能在命令行中使用npm。</p><h3 id="设置文件夹权限"><a href="#设置文件夹权限" class="headerlink" title="设置文件夹权限"></a>设置文件夹权限</h3><p>本篇中需要注意的一点是，设置npm的路径和环境变量时在nodejs文件夹中创建的两个node_cache和node_global文件夹需要在各自的属性中给与用户所有权限，否则会导致npm报错。</p><p><img src="https://cdn.jsdelivr.net/gh/0Rayhlei0/Pics/post_img/image-20220211002517309.png" alt="给予用户完全控制权限"></p><h3 id="Hexo是什么？"><a href="#Hexo是什么？" class="headerlink" title="Hexo是什么？"></a>Hexo是什么？</h3><p>根据Hexo的<a href="https://hexo.io/docs/" title="Hexo Documentation">官方文档</a>，Node.js与Git都是使用Hexo的必要条件，而Hexo本身则是一个免费的博客框架，换句话说既是已经写好的“网站积木”，有了Hexo我们就不需要完全重新设计搭建网站，被古老的html语言折磨，而可以用已有的积木搭出我们想要的网站的样子，主流的博客框架除了Hexo还有与GitHub Pages绑定的Jekyll，尽管看到不少网友鼓吹Jekyll的便捷，但我看着网上大部分由Hexo搭建的博客网站想想大概人类的本质就是口嫌体直罢。</p><p>关于Hexo相关的命令有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder] <span class="comment"># 该命令在提供的文件夹下初始化一个网站，如果没有提供文件夹路径则在当前路径初始化。完成导入hexo-starter到目标文件夹并安装依赖包。</span></span><br><span class="line">$ hexo g <span class="comment"># 等同于 hexo generate，该命令将文件夹中的资源文件生成部署网站用的静态文件，这也是我们刚刚提到的Hexo最重要的作用，将积木搭成城堡的一步。</span></span><br><span class="line">$ hexo s <span class="comment"># 等同于hexo server，启动本地服务器。该命令用于预览已经做出的更改，但不会推送至远程仓库部署，使用该命令不需要hexo g即可默认从http://localhost:4000/本地预览网站的样子。</span></span><br><span class="line">$ hexo clean <span class="comment"># 该命令用于清除缓存文件db.json和已经生成的静态文件Public, hexo g之前最好先运行此命令以免造成generate的文件出现难以预估的问题。</span></span><br><span class="line">$ hexo d <span class="comment">#等同于hexo deploy，使用此命令将目前文件夹中的静态文件部署到设定的仓库（网站）。</span></span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>感谢枫叶大佬的详细介绍才使得我一个完全没有接触过类似东西的人得以在几天内忙里偷闲搭起了这样一个网站，像是有了一个小小的自己的空间，非常感激。即使第六篇之后，也就是网站的主题选择我没有像枫叶大佬一样选择Next主题，而是用了目前看起来更新更符合我审美的<a href="https://butterfly.js.org/" title="Butterfly Documentation">Butterfly</a>，我也依然在配置Hexo的主题文件等等问题上很大程度上参考了大部分第八篇的内容。</p><p>另外必须给大家推荐我现在使用的这个主题, 这是最符合我审美并且自由度相当高的一款主题，网站上有相当详细的文档，大家配置主题的时候跟着文档走就可以完成大部分的网站配置了。</p>]]></content:encoded>
      
      
      <category domain="http://raylei.space/categories/%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4/">博客维护</category>
      
      
      <category domain="http://raylei.space/tags/Blog/">Blog</category>
      
      <category domain="http://raylei.space/tags/Hexo/">Hexo</category>
      
      <category domain="http://raylei.space/tags/GitHub/">GitHub</category>
      
      <category domain="http://raylei.space/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/">日常学习</category>
      
      
      <comments>http://raylei.space/2022/02/10/1-blog_setup_notes/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
